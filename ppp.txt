import streamlit as st
import sqlite3
import os
import time
import uuid
import threading
import datetime
import extra_streamlit_components as stx
from datetime import datetime, timedelta, timezone
import httpx
import requests
import re
import random
import string
import html
from urllib.parse import quote
from retrying import retry

# ==========================================
# 0. æ•°æ®åº“ç®¡ç† (SQLite3 ç‰ˆ - æ›´å¿«æ›´ç¨³)
# ==========================================
DB_FILE = "linkchanger.db"

class DBManager:
    def __init__(self):
        self._init_db()

    def _get_conn(self):
        # check_same_thread=False å…è®¸ Streamlit å¤šçº¿ç¨‹è®¿é—®
        return sqlite3.connect(DB_FILE, check_same_thread=False)

    def _init_db(self):
        conn = self._get_conn()
        c = conn.cursor()
        # åˆ›å»ºç”¨æˆ·è¡¨ï¼šUIDä½œä¸ºä¸»é”®ï¼Œä¿è¯å”¯ä¸€
        c.execute('''CREATE TABLE IF NOT EXISTS users (
                        uid TEXT PRIMARY KEY,
                        name TEXT,
                        pin TEXT,
                        wechat TEXT,
                        q_cookie TEXT,
                        b_cookie TEXT,
                        q_img TEXT,
                        b_img TEXT,
                        b_pwd TEXT,
                        created_at TEXT
                    )''')
        conn.commit()
        conn.close()

    # --- ç”¨æˆ·æ“ä½œ ---
    def add_user(self, uid, name, pin, wechat):
        conn = self._get_conn()
        c = conn.cursor()
        try:
            created_at = datetime.now().strftime("%Y-%m-%d %H:%M")
            c.execute("INSERT INTO users (uid, name, pin, wechat, q_cookie, b_cookie, q_img, b_img, b_pwd, created_at) VALUES (?, ?, ?, ?, '', '', '', '', '', ?)",
                      (uid, name, pin, wechat, created_at))
            conn.commit()
            return True, "æ·»åŠ æˆåŠŸ"
        except sqlite3.IntegrityError:
            return False, "UID å·²å­˜åœ¨ï¼Œè¯·æ¢ä¸€ä¸ª"
        except Exception as e:
            return False, f"æ•°æ®åº“é”™è¯¯: {e}"
        finally:
            conn.close()

    def get_user(self, uid):
        conn = self._get_conn()
        c = conn.cursor()
        c.execute("SELECT * FROM users WHERE uid=?", (uid,))
        row = c.fetchone()
        conn.close()
        if row:
            # å°†å…ƒç»„è½¬ä¸ºå­—å…¸ï¼Œæ–¹ä¾¿ä½¿ç”¨
            return {
                "uid": row[0], "name": row[1], "pin": row[2], "wechat": row[3],
                "q": row[4], "b": row[5], 
                "q_img": row[6], "b_img": row[7], "b_pwd": row[8]
            }
        return None

    def get_all_users(self):
        conn = self._get_conn()
        c = conn.cursor()
        c.execute("SELECT uid, name, wechat, created_at FROM users")
        rows = c.fetchall()
        conn.close()
        return rows # list of tuples

    def update_user_profile(self, uid, name, pin, q, b, q_img, b_img, b_pwd):
        conn = self._get_conn()
        c = conn.cursor()
        c.execute('''UPDATE users SET 
                     name=?, pin=?, q_cookie=?, b_cookie=?, 
                     q_img=?, b_img=?, b_pwd=? 
                     WHERE uid=?''', 
                  (name, pin, q, b, q_img, b_img, b_pwd, uid))
        conn.commit()
        conn.close()

    def delete_user(self, uid):
        conn = self._get_conn()
        c = conn.cursor()
        c.execute("DELETE FROM users WHERE uid=?", (uid,))
        conn.commit()
        conn.close()

db = DBManager()

# ==========================================
# 1. æ ¸å¿ƒ Engine ä¸ Worker (è¯·å¡«å…¥ä½ çš„çœŸå®ä»£ç )
# ==========================================
# ğŸ”´ğŸ”´ğŸ”´ æå…¶é‡è¦ï¼šè¯·åœ¨æ­¤å¤„ç²˜è´´ä½ åŸæœ¬å¥½ç”¨çš„ QuarkEngine, BaiduEngine, JobManager ä»£ç  ğŸ”´ğŸ”´ğŸ”´
# ğŸ”´ğŸ”´ğŸ”´ å¦åˆ™ç¨‹åºæ— æ³•è¿è¡Œè½¬å­˜åŠŸèƒ½ ğŸ”´ğŸ”´ğŸ”´

# --- Mock ä»£ç å¼€å§‹ (ä»…ç”¨äºæ¼”ç¤ºç»“æ„ï¼Œè¯·æ›¿æ¢) ---
# (ä¸ºäº†èŠ‚çœç¯‡å¹…ï¼Œå‡è®¾ä½ å·²ç»æŠŠ helper functions, QuarkEngine, BaiduEngine è´´åœ¨è¿™é‡Œäº†)

# è¿™é‡Œæˆ‘åªæ”¾ JobManagerï¼Œé˜²æ­¢æŠ¥é”™
@st.cache_resource
class JobManager:
    def __init__(self): self.jobs = {}
    def create_job(self): 
        jid = str(uuid.uuid4())[:8]
        self.jobs[jid] = {"status": "running", "logs": [], "result_text": "", "progress": {"current":0,"total":0}, "created_at": datetime.now(), "summary": {}}
        return jid
    def get_job(self, jid): return self.jobs.get(jid)
    def add_log(self, jid, msg, type="info"): 
        if jid in self.jobs: self.jobs[jid]["logs"].append({"time": "00:00", "msg": msg, "type": type})
    def complete_job(self, jid, text, sum): 
        if jid in self.jobs: 
            self.jobs[jid]["status"]="done"; self.jobs[jid]["result_text"]=text; self.jobs[jid]["summary"]=sum
    def update_progress(self, jid, c, t):
        if jid in self.jobs: self.jobs[jid]["progress"] = {"current": c, "total": t}

job_manager = JobManager()

def worker_thread(job_id, input_text, q_c, b_c, bark, push, img_conf):
    # ğŸ”´ è¯·æ›¿æ¢ä¸ºçœŸå®çš„ worker_thread é€»è¾‘
    time.sleep(1)
    job_manager.complete_job(job_id, input_text + "\n(å¤„ç†å®Œæ¯•)", {"success": 1, "total": 1, "duration": "1s"})
# --- Mock ä»£ç ç»“æŸ ---


# ==========================================
# 2. ç•Œé¢è§†å›¾é€»è¾‘
# ==========================================
st.set_page_config(page_title="LinkChanger Pro", page_icon="âš¡", layout="wide")

def get_manager():
    return stx.CookieManager()

def page_admin():
    st.markdown("## ğŸ›¡ï¸ ç”¨æˆ·ç®¡ç†åå°")
    
    # ç®€å•çš„åå°å¯†ç éªŒè¯ (ä» secrets è¯»å–)
    ADMIN_PWD = st.secrets.get("general", {}).get("admin_password", "admin888")
    
    if "admin_logged_in" not in st.session_state:
        pwd = st.text_input("è¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç ", type="password")
        if st.button("ç™»å½•"):
            if pwd == ADMIN_PWD:
                st.session_state.admin_logged_in = True
                st.rerun()
            else:
                with st.spinner("éªŒè¯ä¸­..."):
                    time.sleep(2) # é˜²çˆ†ç ´å»¶è¿Ÿ
                st.error("å¯†ç é”™è¯¯")
        return

    # === æ–°å¢ç”¨æˆ·è¡¨å• ===
    with st.container(border=True):
        st.subheader("â• æ–°å¢ç”¨æˆ·")
        c1, c2 = st.columns(2)
        new_uid = c1.text_input("åˆ†é… UID (å¦‚: tony, vip1)", help="ç”¨æˆ·å°†é€šè¿‡ ?uid=è¿™ä¸ªå€¼ è®¿é—®")
        new_name = c2.text_input("ç”¨æˆ·æ˜µç§°")
        c3, c4 = st.columns(2)
        new_wechat = c3.text_input("ç”¨æˆ·å¾®ä¿¡å· (ä»…è®°å½•)")
        new_pin = c4.text_input("åˆå§‹å¯†ç ", value="123456")
        
        if st.button("åˆ›å»ºç”¨æˆ·", type="primary"):
            if not new_uid or not new_name:
                st.error("UID å’Œ æ˜µç§° å¿…å¡«")
            else:
                ok, msg = db.add_user(new_uid, new_name, new_pin, new_wechat)
                if ok:
                    st.success(f"ç”¨æˆ· {new_name} åˆ›å»ºæˆåŠŸï¼")
                    st.info(f"è¯·å¤åˆ¶é“¾æ¥å‘ç»™ä»–: `?uid={new_uid}`")
                    time.sleep(2)
                    st.rerun()
                else:
                    st.error(msg)

    st.divider()
    
    # === ç”¨æˆ·åˆ—è¡¨ ===
    st.subheader("ğŸ‘¥ ç”¨æˆ·åˆ—è¡¨")
    users = db.get_all_users() # [(uid, name, wechat, time), ...]
    
    if not users:
        st.caption("æš‚æ— ç”¨æˆ·")
    
    for u in users:
        uid, name, wechat, t = u
        with st.expander(f"ğŸ‘¤ {name} (UID: {uid})"):
            st.write(f"å¾®ä¿¡å·: `{wechat}`")
            st.write(f"åˆ›å»ºæ—¶é—´: {t}")
            st.code(f"?uid={uid}")
            
            if st.button("ğŸ—‘ï¸ åˆ é™¤è¯¥ç”¨æˆ·", key=f"del_{uid}"):
                db.delete_user(uid)
                st.warning(f"ç”¨æˆ· {uid} å·²åˆ é™¤")
                time.sleep(1)
                st.rerun()

def page_user_tool(uid):
    # æ¯æ¬¡åˆ·æ–°éƒ½ä»æ•°æ®åº“è¯»æœ€æ–°æ•°æ®
    user_data = db.get_user(uid)
    if not user_data:
        st.error("âŒ è´¦å·ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤")
        return

    # === ä¾§è¾¹æ ï¼šä¸ªäººé…ç½® ===
    with st.sidebar:
        st.header(f"ğŸ‘¤ {user_data['name']}")
        
        with st.expander("âš™ï¸ ä¸ªäººé…ç½®", expanded=False):
            # 1. åªè¯»åŒºåŸŸ
            st.caption("ğŸš« ä»¥ä¸‹ä¿¡æ¯ä¸å¯ä¿®æ”¹")
            st.text_input("ä¸“å± UID", value=user_data['uid'], disabled=True)
            st.text_input("ç»‘å®šå¾®ä¿¡å·", value=user_data['wechat'], disabled=True)
            
            st.divider()
            
            # 2. å¯ä¿®æ”¹åŒºåŸŸ
            st.caption("âœï¸ å¯ä¿®æ”¹ä¿¡æ¯")
            new_name = st.text_input("æ˜µç§°", value=user_data['name'])
            new_pin = st.text_input("ç™»å½•å¯†ç ", value=user_data['pin'], type="password")
            
            st.caption("ğŸª ç½‘ç›˜ Cookie (å¿…å¡«)")
            new_q = st.text_area("å¤¸å…‹ Cookie", value=user_data['q'], height=100)
            new_b = st.text_area("ç™¾åº¦ Cookie", value=user_data['b'], height=100)
            
            st.caption("ğŸ“¢ å¹¿å‘Šä¸æ¤å…¥ (é€‰å¡«)")
            new_q_img = st.text_input("å¤¸å…‹å¹¿å‘Šé“¾æ¥", value=user_data['q_img'])
            new_b_img = st.text_input("ç™¾åº¦å¹¿å‘Šé“¾æ¥", value=user_data['b_img'])
            new_b_pwd = st.text_input("ç™¾åº¦æå–ç ", value=user_data['b_pwd'])
            
            if st.button("ğŸ’¾ ä¿å­˜é…ç½®"):
                db.update_user_profile(
                    uid, new_name, new_pin, 
                    new_q, new_b, 
                    new_q_img, new_b_img, new_b_pwd
                )
                st.toast("ä¿å­˜æˆåŠŸï¼ä¸‹æ¬¡ç™»å½•ç”Ÿæ•ˆ", icon="âœ…")
                time.sleep(1)
                st.rerun()

        if st.button("ğŸšª é€€å‡ºç™»å½•"):
             get_manager().delete(f"auth_{uid}")
             st.query_params.clear()
             st.rerun()

    # === ä¸»å·¥å…·ç•Œé¢ ===
    st.title("âš¡ ç½‘ç›˜è½¬å­˜åŠ©æ‰‹")
    
    # Cookie çŠ¶æ€æç¤º
    q_ok = bool(user_data['q'])
    b_ok = bool(user_data['b'])
    
    if not q_ok and not b_ok:
        st.warning("ğŸ‘ˆ è¯·å…ˆç‚¹å‡»å·¦ä¾§ **ã€ä¸ªäººé…ç½®ã€‘** å¡«å…¥ç½‘ç›˜ Cookie æ‰èƒ½ä½¿ç”¨ï¼")
    
    # ä»»åŠ¡æäº¤é€»è¾‘
    input_text = st.text_area("ç²˜è´´åˆ†äº«é“¾æ¥ (æ”¯æŒæ··åˆç²˜è´´)", height=150)
    
    if st.button("ğŸš€ å¼€å§‹è½¬å­˜", type="primary", use_container_width=True):
        if not input_text.strip(): return
        if not q_ok and not b_ok:
            st.error("æœªé…ç½®ä»»ä½• Cookieï¼Œæ— æ³•ä»»åŠ¡")
            return
            
        jid = job_manager.create_job()
        
        # ç»„è£…é…ç½®ä¼ ç»™ Worker
        img_conf = {
            "quark": {"url": user_data['q_img'], "enabled": bool(user_data['q_img'])},
            "baidu": {"url": user_data['b_img'], "pwd": user_data['b_pwd'], "enabled": bool(user_data['b_img'])}
        }
        
        # å¯åŠ¨çº¿ç¨‹
        t = threading.Thread(target=worker_thread, args=(
            jid, input_text, 
            user_data['q'], user_data['b'], 
            "", "", # æ¨é€keyæš‚æ—¶ç•™ç©ºï¼Œå¦‚æœæ•°æ®åº“åŠ å­—æ®µå¯ä¼ å…¥
            img_conf
        ))
        t.start()
        st.query_params["job_id"] = jid
        st.query_params["uid"] = uid
        st.rerun()

    # ä»»åŠ¡çŠ¶æ€å›æ˜¾
    curr_jid = st.query_params.get("job_id")
    if curr_jid:
        job = job_manager.get_job(curr_jid)
        if job:
            if job['status'] == 'running':
                st.info("ğŸ”„ å¤„ç†ä¸­...")
            elif job['status'] == 'done':
                st.success("âœ… å®Œæˆ")
                st.text_area("ç»“æœ", value=job['result_text'])
                if st.button("å¼€å§‹æ–°ä»»åŠ¡"):
                    st.query_params["job_id"] = ""
                    st.query_params["uid"] = uid
                    st.rerun()
            
            # æ˜¾ç¤ºæ—¥å¿—
            with st.expander("æ‰§è¡Œæ—¥å¿—", expanded=True):
                for log in job['logs']:
                    st.text(f"{log['time']} - {log['msg']}")

# ==========================================
# 3. ç¨‹åºå…¥å£ (Main)
# ==========================================
def main():
    # è·å– URL å‚æ•°
    uid_param = st.query_params.get("uid", None)

    # ä» secrets è¯»å–éšè—çš„ç®¡ç†å‘˜ UID
    HIDDEN_ADMIN_UID = st.secrets.get("general", {}).get("admin_uid", "admin_entry_default")

    # 1. æ²¡æœ‰ UID -> æ˜¾ç¤º403é¡µé¢
    if not uid_param:
        st.title("ğŸš« Access Denied")
        st.warning("æœ¬å·¥å…·ä¸ºå†…éƒ¨é‚€è¯·åˆ¶ã€‚è¯·è”ç³»ç®¡ç†å‘˜è·å–ä¸“å±è®¿é—®é“¾æ¥ã€‚")
        return

    # 2. ç®¡ç†å‘˜å…¥å£
    if uid_param == HIDDEN_ADMIN_UID:
        page_admin()
        return

    # 3. æ™®é€šç”¨æˆ·é‰´æƒ
    user_data = db.get_user(uid_param)
    if not user_data:
        st.error("ğŸš« æ— æ•ˆçš„é“¾æ¥ (UID Error)")
        return
    
    # Cookie è‡ªåŠ¨ç™»å½•æ£€æŸ¥
    cookie_manager = get_manager()
    cookie_key = f"auth_{uid_param}"
    
    if cookie_manager.get(cookie_key) == "logged_in":
        page_user_tool(uid_param)
        return
    
    # å¯†ç é”å±
    st.markdown(f"### ğŸ”’ {user_data['name']}ï¼Œè¯·è§£é”")
    pin_input = st.text_input("è¯·è¾“å…¥å¯†ç ", type="password")
    
    if st.button("è§£é”"):
        if pin_input == user_data['pin']:
            # ç™»å½•æˆåŠŸï¼Œå†™å…¥æµè§ˆå™¨Cookie
            cookie_manager.set(cookie_key, "logged_in", expires_at=datetime.now() + timedelta(days=30))
            st.rerun()
        else:
            time.sleep(1)
            st.error("å¯†ç é”™è¯¯")

if __name__ == "__main__":
    main()
